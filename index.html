<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/jquery.terminal.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/jquery.terminal/css/jquery.terminal.min.css" rel="stylesheet"/>
    <link href="renderedhtml.css" rel="stylesheet"/>
    <script src="https://pyodide.cdn.iodide.io/pyodide.js"></script>
  </head>
  <body>
    <script>
      let DEBUG = true;
      languagePluginLoader.then(() => {
        function pushCode(line) {
            push(line)
        }

        let pushLineNoRun = function() {
            // push the current line, and ensure the buffer isn't executed.
            let cmd = term.get_command();
            term.set_command('');
            term.history().append(cmd);
            set_try_run(false);
            term.exec(cmd, false)
        }

        var term = $('body').terminal(
          pushCode,
          {
            greetings: "Welcome to the Pyodide terminal emulator 🐍",
            prompt: "[[;grey;]>>> ]",
            exceptionHandler: (e) => {
                console.log(e.message);
                console.log(e.stack);
                term.error(e.message);
            },
            keymap: {
                "SHIFT+ENTER": (e, orig) => pushLineNoRun(),
                "BACKSPACE": (e, orig) => {
                    // Allow backspace to remove a line.
                    let cmd = term.get_command();
                    if (cmd.length > 0) {
                        orig();  // Normal backspace if there are characters.
                    } else {
                        let buffer_len = get_buffer_len();
                        if (buffer_len == 0) {return}; 
                        term.remove_line(-1);
                        let new_cmd = pop();
                        term.set_command(new_cmd)
                        if (buffer_len == 1) {
                            term.set_prompt('[[;gray;]>>> ]');
                        }
                    }
                },
            }
          }
        );

        window.term = term;
        pyodide.runPython(String.raw`
        import io, code, sys
        from js import term, pyodide
        
        _buffer = []
        _try_run = True;

        class StringIORedirect(io.StringIO):
            """ StringIO, but everything is echoed to the terminal."""
            def __init__(self, colour=None, *args, **kwargs):
                self.colour = colour
                super().__init__(*args, **kwargs)
            def write(self, *args, **kwargs):
                # super().write(*args, **kwargs)
                if self.colour is None:
                    term.echo(args[0])
                else:
                    term.echo(f"[[;{self.colour};]{args[0]}]")
        
        sys.stdout = StringIORedirect()
        sys.stderr = StringIORedirect('red')

        def _set_try_run(val):
            global _try_run
            _try_run = val

        def _get_buffer_len():
            return len(_buffer)

        def _push(line):
            """Add line of code to buffer and execute it if ready."""
            _buffer.append(line)
            
            if _try_run:
                # Always exec if final line is blank.
                if line == "":
                    return _exec_buffer()
                
                # Exec on single line input 
                if len(_buffer) == 1:
                    try:
                        if code.compile_command(line):
                            return _exec_buffer()
                    except (OverflowError, SyntaxError, ValueError):
                        pass  # Allow these to occur when the user executes the code.

            _set_try_run(True)  # Always default back to true for next input.
            # More input expected, set prompt accordingly.
            term.set_prompt('[[;gray;]... ]')
        
        def _pop():
            return _buffer.pop()


        def _exec_buffer():
            """ Execute and clear the buffer. """
            code_str = "\n".join(_buffer)
            display = len(_buffer)==1  # Only display if code is a single line.
            _buffer.clear()
            term.set_prompt('[[;grey;]>>> ]')
            term.runPython(code_str, display)
        `)

        var push = pyodide.pyimport('_push')
        var set_try_run = pyodide.pyimport('_set_try_run')
        var get_buffer_len = pyodide.pyimport('_get_buffer_len')
        var pop = pyodide.pyimport('_pop')

        term.runPython = function(code, display) {
          if(DEBUG) {console.log(code)};
          pyodide.runPythonAsync(code).then(
            (r) => term.displayExpressionResult(r, display), term.handlePythonError
          )
        }
        
        term.displayExpressionResult = function(result, display) {
          if (display) {
            if (result === undefined) {
                    return
                } else if (result['_repr_html_'] !== undefined) {
                    term.echo(result['_repr_html_'], {raw: true})
                } else {
                    term.echo(result.toString())
            }
          }
        }

        term.handlePythonError = function(result) {
          if (DEBUG) {console.log("term error result")}
          term.error(result.toString())
        }
        
        // automate input to terminal:
        // term.exec("print(1)", false)
      });
    </script>
  </body>
</html>
