<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/jquery.terminal.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/jquery.terminal/css/jquery.terminal.min.css" rel="stylesheet"/>
    <link href="renderedhtml.css" rel="stylesheet"/>
    <script src="https://pyodide.cdn.iodide.io/pyodide.js"></script>
  </head>
  <body>
    <script>
      let DEBUG = true;
      let RUNNING = false;
      var TRY_RUN = true;  // If false the buffer will not be executed when pressing enter.

      function __delay__(timer) {
            // Delay for timer milliseconds
            // https://stackoverflow.com/a/51212718/8899565
            return new Promise(resolve => {
                timer = timer || 2000;
                setTimeout(function () {
                    resolve();
                }, timer);
            });
        };

      languagePluginLoader.then(() => {
        async function pushCode(line) {
            push(line);
            // code might still be running at this point.
            // todo maybe have an error after a certain amount of time.
            while (RUNNING)
                await __delay__(5);
            TRY_RUN = true;  // Default back to true.
        }

        var term = $('body').terminal(
          pushCode,
          {
            greetings: "Welcome to the Pyodide terminal emulator 🐍",
            prompt: "[[;grey;]>>> ]",
            exceptionHandler: (e) => {
                console.log(e.message);
                console.log(e.stack);
                term.error(e.message);
            },
            keymap: {
                "SHIFT+ENTER": (e, orig) => {
                    // pushLineNoRun()
                    TRY_RUN = false;
                    let cmd = term.get_command();
                    term.set_command('');
                    term.history().append(cmd);
                    term.exec(cmd, false)
                },
                "BACKSPACE": (e, orig) => {
                    // Allow backspace to remove a line.
                    let cmd = term.get_command();
                    if (cmd.length > 0) {
                        orig();  // Normal backspace if there are characters.
                    } else {
                        let buffer_len = pyodide.runPython('len(_buffer)');
                        if (buffer_len == 0) {return};
                        term.remove_line(-1);
                        let new_cmd = pyodide.runPython('_buffer.pop()');
                        term.set_command(new_cmd)
                        if (buffer_len == 1) {
                            term.set_prompt('[[;gray;]>>> ]');
                        }
                    }
                },
                "CTRL+C": (e, orig) => {
                    // Cancel current input.
                    let cmd = term.get_command();
                    term.insert('^C');
                    let cancelled_line = term.get_prompt() + term.get_command();
                    if (cmd.trim().length > 0){
                        term.history().append(term.get_command());
                    }
                    pyodide.runPython('_buffer.clear()');
                    term.set_command('');
                    term.exec('', false);
                    term.update(-1, cancelled_line);
                    console.log(cancelled_line)
                }
            }
          }
        );

        window.term = term;
        pyodide.runPython(String.raw`
        import io
        import code
        import sys
        from js import term, pyodide as pyodidejs, console
        import pyodide
        import js
        
        _buffer = []

        class _StringIORedirect(io.StringIO):
            """ StringIO, but everything is echoed to the terminal."""
            def __init__(self, *args, **kwargs):
                self.line_buffer = ''
                super().__init__(*args, **kwargs)
            def write(self, *args, **kwargs):
                # super().write(*args, **kwargs)

                # Start a new line if there isn't one already
                if not self.line_buffer:
                    term.echo('')
                self.line_buffer += args[0]
                # console.log(self.line_buffer)
                term.update(-1, self.line_buffer)
        
        sys.stdout = _StringIORedirect()
        # sys.stderr = _StringIORedirect('red')
        sys.stderr = sys.stdout

        def _push(line):
            """Add line of code to buffer and execute it if ready."""
            _buffer.append(line)
            
            if js.TRY_RUN:
                # Always exec if final line is whitespace.
                if line.strip() == "":
                    return _exec_buffer()
                
                # Exec on single line input 
                if len(_buffer) == 1:
                    try:
                        if code.compile_command(line):
                            return _exec_buffer()
                    except (OverflowError, SyntaxError, ValueError):
                        pass  # Allow these to occur when the user executes the code.

            # More input expected, set prompt accordingly.
            term.set_prompt('[[;gray;]... ]')


        def _exec_buffer():
            """ Execute and clear the buffer. """
            sys.stdout.line_buffer = ''
            sys.stderr.line_buffer = ''
            code_str = "\n".join(_buffer)
            display = len(_buffer)==1  # Only display if code is a single line.
            _buffer.clear()
            term.set_prompt('[[;grey;]>>> ]')
            res = pyodide.eval_code(code_str, globals())
            if display and res is not None:
                if hasattr(res, '__repr__'):
                    print(res.__repr__(), end='')
                else:
                    print(res, end='')
        `)

        var push = pyodide.pyimport('_push')

        term.runPython = function(code, display) {
          if(DEBUG) {console.log(code)};
          RUNNING = true;
          pyodide.runPythonAsync(code).then(
            (r) => term.displayExpressionResult(r, display), term.handlePythonError
          )
        }
        
        term.displayExpressionResult = function(result, display) {
          RUNNING = false;
          if (display) {
            if (result === undefined) {
                    return
                } else if (result['_repr_html_'] !== undefined) {
                    term.echo(result['_repr_html_'], {raw: true})
                } else {
                    term.echo(result.toString())
            }
          }
        }

        term.handlePythonError = function(result) {
          RUNNING = false;
          if (DEBUG) {console.log("term error result")}
          term.error(result.toString())
        }
      });
    </script>
  </body>
</html>
