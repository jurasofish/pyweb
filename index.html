<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/jquery.terminal.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/jquery.terminal/css/jquery.terminal.min.css" rel="stylesheet"/>
    <link href="renderedhtml.css" rel="stylesheet"/>
    <script src="https://pyodide.cdn.iodide.io/pyodide.js"></script>
  </head>
  <body>
    <script>
      let DEBUG = true;
      let RUNNING = false;

      function __delay__(timer) {
            // Delay for timer milliseconds
            // https://stackoverflow.com/a/51212718/8899565
            return new Promise(resolve => {
                timer = timer || 2000;
                setTimeout(function () {
                    resolve();
                }, timer);
            });
        };

      languagePluginLoader.then(() => {
        async function pushCode(line) {
            push(line);
            // code might still be running at this point.
            // todo maybe have an error after a certain amount of time.
            while (RUNNING)
                await __delay__(5);
        }

        let pushLineNoRun = function() {
            // push the current line, and ensure the buffer isn't executed.
            let cmd = term.get_command();
            term.set_command('');
            term.history().append(cmd);
            set_try_run(false);
            term.exec(cmd, false)
        }

        var term = $('body').terminal(
          pushCode,
          {
            greetings: "Welcome to the Pyodide terminal emulator 🐍",
            prompt: "[[;grey;]>>> ]",
            exceptionHandler: (e) => {
                console.log(e.message);
                console.log(e.stack);
                term.error(e.message);
            },
            keymap: {
                "SHIFT+ENTER": (e, orig) => pushLineNoRun(),
                "BACKSPACE": (e, orig) => {
                    // Allow backspace to remove a line.
                    let cmd = term.get_command();
                    if (cmd.length > 0) {
                        orig();  // Normal backspace if there are characters.
                    } else {
                        let buffer_len = get_buffer_len();
                        if (buffer_len == 0) {return};
                        term.remove_line(-1);
                        let new_cmd = pop();
                        term.set_command(new_cmd)
                        if (buffer_len == 1) {
                            term.set_prompt('[[;gray;]>>> ]');
                        }
                    }
                },
                "CTRL+C": (e, orig) => {
                    // Cancel current input.
                    let cmd = term.get_command();
                    term.insert('^C');
                    let cancelled_line = term.get_prompt() + term.get_command();
                    if (cmd.trim().length > 0){
                        term.history().append(term.get_command());
                    }
                    clear_buffer();
                    term.set_command('');
                    term.exec('', false);
                    term.update(-1, cancelled_line);
                    console.log(cancelled_line)
                }
            }
          }
        );

        window.term = term;
        pyodide.runPython(String.raw`
        import io
        import code
        import sys
        from js import term, pyodide as pyodidejs, console
        import pyodide
        
        _buffer = []
        _try_run = True

        class _StringIORedirect(io.StringIO):
            """ StringIO, but everything is echoed to the terminal."""
            def __init__(self, colour='', *args, **kwargs):
                self.colour = colour
                self.line_buffer = ''
                super().__init__(*args, **kwargs)
            def write(self, *args, **kwargs):
                # super().write(*args, **kwargs)

                # Start a new line if there isn't one already
                if not self.line_buffer:
                    term.echo('')
                self.line_buffer += args[0]
                term.update(-1, f"[[;{self.colour};]{self.line_buffer}]")
        
        sys.stdout = _StringIORedirect()
        # sys.stderr = _StringIORedirect('red')
        sys.stderr = sys.stdout

        def _set_try_run(val):
            global _try_run
            _try_run = val

        def _get_buffer_len():
            return len(_buffer)
        
        def _pop():
            return _buffer.pop()
        
        def _clear_buffer():
            _buffer.clear()

        def _push(line):
            """Add line of code to buffer and execute it if ready."""
            _buffer.append(line)
            
            if _try_run:
                # Always exec if final line is whitespace.
                if line.strip() == "":
                    return _exec_buffer()
                
                # Exec on single line input 
                if len(_buffer) == 1:
                    try:
                        if code.compile_command(line):
                            return _exec_buffer()
                    except (OverflowError, SyntaxError, ValueError):
                        pass  # Allow these to occur when the user executes the code.

            _set_try_run(True)  # Always default back to true for next input.
            # More input expected, set prompt accordingly.
            term.set_prompt('[[;gray;]... ]')


        def _exec_buffer():
            """ Execute and clear the buffer. """
            sys.stdout.line_buffer = ''
            sys.stderr.line_buffer = ''
            code_str = "\n".join(_buffer)
            display = len(_buffer)==1  # Only display if code is a single line.
            _buffer.clear()
            term.set_prompt('[[;grey;]>>> ]')
            res = pyodide.eval_code(code_str, globals())
            if display and res is not None:
                if hasattr(res, '__repr__'):
                    print(res.__repr__(), end='')
                else:
                    print(res, end='')
        `)

        var push = pyodide.pyimport('_push')
        var set_try_run = pyodide.pyimport('_set_try_run')
        var get_buffer_len = pyodide.pyimport('_get_buffer_len')
        var pop = pyodide.pyimport('_pop')
        var clear_buffer = pyodide.pyimport('_clear_buffer')

        term.runPython = function(code, display) {
          if(DEBUG) {console.log(code)};
          RUNNING = true;
          pyodide.runPythonAsync(code).then(
            (r) => term.displayExpressionResult(r, display), term.handlePythonError
          )
        }
        
        term.displayExpressionResult = function(result, display) {
          RUNNING = false;
          if (display) {
            if (result === undefined) {
                    return
                } else if (result['_repr_html_'] !== undefined) {
                    term.echo(result['_repr_html_'], {raw: true})
                } else {
                    term.echo(result.toString())
            }
          }
        }

        term.handlePythonError = function(result) {
          RUNNING = false;
          if (DEBUG) {console.log("term error result")}
          term.error(result.toString())
        }
      });
    </script>
  </body>
</html>
